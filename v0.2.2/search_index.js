var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Basic-Usage","page":"API","title":"Basic Usage","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is an example illustrating the basic API.","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PolyhderalRelaxations, JuMP\nm = Model() \n@variable(m, -1.0 <= x <= 1.0)\n@variable(m, y)\nf = x -> x^3\nconstruct_univariate_relaxation!(m, f, x, y, [-1.0, 0.0, 1.0], true)","category":"page"},{"location":"api/","page":"API","title":"API","text":"For more examples and details on the helper functions, the reader is referred to the unit tests in the test/ folder of the GitHub repository.","category":"page"},{"location":"api/#API-for-the-MILP/LP-Relaxation-for-Nonlinear-Univariate-function","page":"API","title":"API for the MILP/LP Relaxation for Nonlinear Univariate function","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Both the MILP and the LP relaxations for a given nonlinear univariate function are","category":"page"},{"location":"api/","page":"API","title":"API","text":"construct_univariate_relaxation!","category":"page"},{"location":"api/#PolyhedralRelaxations.construct_univariate_relaxation!","page":"API","title":"PolyhedralRelaxations.construct_univariate_relaxation!","text":"construct_univariate_relaxation!(m,x,y,f,x_partition;f_dash=x->ForwardDiff.derivative(f,x),error_tolerance=NaN64,length_tolerance=ϵ,derivative_tolerance=ϵ,num_additional_partitions=0)\n\nAdd MILP relaxation of y=f(x) to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\nf::Function: function or oracle for which a polyhedral relaxation is   required, usually non-linear.\nx::Jump.VariableRef: JuMP variable for domain of f.\ny::JuMP.VariableRef: JuMP variable for evaluation of f.\nx_partition::Vector{<:Real}: partition of the domain of f.\nmilp::Bool: build MILP relaxation if true, LP relaxation otherwise. Note   that the MILP relaxation uses the incremental formulation presented in the   paper, but the LP relaxation uses a lambda form that builds a formulation   as the convex combination of triangle vertices that are at the intersection   of tangents to the curve.\n\nOptional Arguments\n\nf_dash::Function: function or oracle for derivative of f, defaults to    the derivative function from the ForwardDiff package.\nerror_tolerance::Float64: Maximum allowed vertical distance between over   and under estimators of f, defaults to NaN64.\nlength_tolerance::Float64: maximum length of a sub-interval in a partition,   defaults to 0.001.\nderivative_tolerance::Float64: minimum absolute difference between   derivaties at successive elements of a partition for them to be considered   different, defaults to 0.001. If the difference of a partition sub-interval   is smaller than this value, that sub-interval will be refined.\nnum_additional_partitions::Int64: budget on number of sub-intervals in   partition, defaults to 0. Note that if the number of partitions is n and   the number of additional partitions is m, then the function will return a   relaxation with at most n+m partitions.\n\nAssume that:\n\nf is a bounded function of 1 variable.\nx_partition is a partition of the domain of f such that f is either   convex or concave each sub-interval of the partition.\nf_dash is not equal at two consecutive elements of x_partition.\n\nThis function builds an incremental formulation, which is the formulation presented in the paper.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The derivate of the function is an optional keyword argument. If the derivate is not specified, the package invokes ForwardDiff.jl to compute the derivative.","category":"page"},{"location":"api/#Additional-Algorithms","page":"API","title":"Additional Algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Apart from providing MILP and LP relaxations of graphs of univariate function y=f(x) for a given partition, the package also implements some basic partitioning algorithms to refine the partition and provide tighter relaxations. Given a partition, PolyhedralRelaxations.jl can refine the partition using an interval-bisection algorithm detailed in the following reference: ","category":"page"},{"location":"api/","page":"API","title":"API","text":"K. Sundar, S. Sanjeevi, and H, Nagarajan (2020). Sequence of Polyhedral Relaxations for Nonlinear Univariate Functions. (arxiv link)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The partition refinement scheme is equipped with multiple stopping criteria that can be toggled by setting non-default values to the following keyword arguments in the standard API:","category":"page"},{"location":"api/","page":"API","title":"API","text":"error_tolerance: this parameter measures the maximum vertical distance between the under- and over-estimators of the relaxation within the domain of the univariate function. By default, this value is set to NaN64. Setting a non-zero positive value for this parameter would result partition and a corresponding relaxation such that the maximum vertical distance between the under- and over-estimators of the relaxation is at most the value prescribed by error_tolerance. \nnum_additional_partitions: this parameter as the name suggests will refine the partition using the interval bisection algorithm till the total number of additional partitions reaches this number. It's default value is set to 0. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The refinement algorithm will stop if either of the above two stopping criteria is satisfied. ","category":"page"},{"location":"api/#Tolerance-parameters","page":"API","title":"Tolerance parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main functions to produce the relaxations are also equipped with the following two tolerance parameters:","category":"page"},{"location":"api/","page":"API","title":"API","text":"length_tolerance: this parameter is used to control the refinement algorithm. A partition whose length is less than the length_tolerance is not partitioned further. The default value of this parameter is epsilon = 0001.\nderivative_tolerance: when the refinement algorithm is used with the base_partition not containing the inflection points of the function in its domain, the resulting relaxations will be erroneous i.e., there is no guarantee that the relaxation obtained is even valid. One necessary condition to detect this issue is by ensuring that the derivatives at successive partition points are not equal. This condition is checked up to the tolerance specified by this parameter. The default value of this parameter is epsilon = 0001.","category":"page"},{"location":"interface/#Using-with-JuMP","page":"Interfacing with JuMP","title":"Using with JuMP","text":"","category":"section"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"This section provides an example of how to use the relaxations provided by PolyhdedralRelaxations in conjunction with JuMP.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The following examples illustrate the interfacing code for y = x^3 on the partition -10 -075 -05 -025 00 025 05 075 10. ","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"# Create MILP relaxation \nusing PolyhderalRelaxations, JuMP, Cbc\ncbc_optimizer = JuMP.optimizer_with_attributes(Cbc.Optimizer, \"logLevel\" => 0)\n\nf, partition = x -> x^3, collect(-1.0:0.25:1.0)\n\n# create the MILP relaxation of the univariate function.\nmilp = Model(cbc_optimizer)\n@variable(milp, -1.0 <= x <= 1.0)\n@variable(milp, y)\nformulation_info_milp = construct_univariate_relaxation!(milp, f, x, y, partition, true)\n\n# create the LP relaxation of the univariate function.\nlp = Model(cbc_optimizer)\n@variable(lp, -1.0 <= x_lp <= 1.0)\n@variable(lp, y_lp)\nformulation_info_lp = construct_univariate_relaxation!(milp, f, x_lp, y_lp, partition, false)","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The formulation_info_milp and formulation_info_lp contains variable and constraint references for all the additional variables and constraints that are used to formulate the polyhedral relaxation. It definition can be found in FormulationInfo.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The reader is referred to manuscript for details on the formulation.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"For an exhaustive list of functions, the reader is referred to PolyhedralRelaxations.jl Function Reference. ","category":"page"},{"location":"reference/#PolyhedralRelaxations.jl-Function-Reference","page":"Reference","title":"PolyhedralRelaxations.jl Function Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PolyhedralRelaxations]","category":"page"},{"location":"reference/#PolyhedralRelaxations.FormulationInfo","page":"Reference","title":"PolyhedralRelaxations.FormulationInfo","text":"The struct FormulationInfo holds two dictionaries, one for variable references and the other for constraint references.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations.FormulationInfo-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.FormulationInfo","text":"Empty contructor for struct FormulationInfo\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.UnivariateFunctionData","page":"Reference","title":"PolyhedralRelaxations.UnivariateFunctionData","text":"The struct UnivariateFunctionData holds the inputs provided by the user. It takes in the function and its derivative (as lambda expressions), the partition on the independent variable that the user provides, and the following 3 tolerance values:\n\nerror tolerance denotes the strength of the relaxation (the closer to zero   the stronger the relaxation)\nlength tolerance (maximum difference between successive derivative values)\nderivative tolerance denotes the tolerance for checking equality of   derivative values at subsequent partition points, and finally, the maximum   number of additional partition intervals.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations.Vertex2d","page":"Reference","title":"PolyhedralRelaxations.Vertex2d","text":"Vertex2d is a pair (x y)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations._build_univariate_lp_relaxation!-Tuple{JuMP.Model,JuMP.VariableRef,JuMP.VariableRef,UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._build_univariate_lp_relaxation!","text":"_build_univariate_lp_relaxation!(univariate_function_data)\n\nBuild LP relaxation for y=f(x) given the univariate function data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_univariate_milp_relaxation!-Tuple{JuMP.Model,JuMP.VariableRef,JuMP.VariableRef,UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._build_univariate_milp_relaxation!","text":"_build_univariate_milp_relaxation!(m,x,y,function_data)\n\nReturn a MILPRelaxation object with constraint and RHS information of the MILP formulation of the polyhedral relaxation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._collect_vertices-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._collect_vertices","text":"_collect_vertices(univariate_function_data)\n\nReturn a pair of lists with secant vertices as the first element and tangent vertices as the second element.\n\nEach element in the secant vertex list is a pair (x,y) where\n\nx is an element of univariate_function_data.partition,\ny is the value of the given univariate function at x.\n\nAll secant vertices lie on the curve.\n\nEach element in the tangent vertex list is also a pair (x,y). Each position i of the list contains the vertex formed by intersection of tangents of the curve y=univariate_function_data.f(x) at secant_vertices[i] and secant_vertices[i+1]. No tangent vertex will lie on the curve (except for the trivial case where the curve is linear, and all triangles are flat lines).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_error_bound-Tuple{Function,Float64,Float64}","page":"Reference","title":"PolyhedralRelaxations._get_error_bound","text":"_get_error_bound(derivative, lb, ub)\n\nGet error bound of a function with derivative derivative in the closed interval [lb,ub].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_error_queue-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_error_queue","text":"_get_error_queue(univariate_function_data)\n\nBuild a max-priority-queue holding errors of each partition interval in univariate_function_data.partition. Keys of the queue are indices of starting positions of the partition interval in univariate_function_data.partition. Priorities are error bounds of partition intervals. The queue is built as a max-queue for easy access to the  maximum error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_lp_relaxation_vertices-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_lp_relaxation_vertices","text":"_get_lp_relaxation_vertices(univariate_function_data::UnivariateFunctionData)::Vector{Vertex2d}\n\nReturn vertices of the LP relaxation of the given function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_max_error_bound-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_max_error_bound","text":"_get_max_error_bound(univariate_function_data)\n\nCompute and return maximum value of error bound among all partition intervals.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_tangent_vertex-Tuple{Pair{var\"#s12\",var\"#s13\"} where var\"#s13\"<:Real where var\"#s12\"<:Real,Pair{var\"#s12\",var\"#s13\"} where var\"#s13\"<:Real where var\"#s12\"<:Real,Function}","page":"Reference","title":"PolyhedralRelaxations._get_tangent_vertex","text":"_get_tangent_vertex(prev_secant_vertex, next_secant_vertex, derivative)\n\nReturn (xy) coordinates of the intersection of tangents drawn at prev_secant_vertex and next_secant_vertex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._is_refinement_feasible-Tuple{UnivariateFunctionData,DataStructures.PriorityQueue}","page":"Reference","title":"PolyhedralRelaxations._is_refinement_feasible","text":"_is_refinement_feasible(univariate_function_data, error_queue)\n\nThis function checks if the refinement is feasible\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._refine_partition!-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._refine_partition!","text":"_refine_partition!(univariate_function_data)\n\nPartition refinement schemes (interval bisection)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{JuMP.VariableRef,Array{var\"#s22\",1} where var\"#s22\"<:Real}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(x, partition)\n\nVariable bounds and partition consistency checker\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(univariate_function_data)\n\nInput univariate function data validator\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate_point-Tuple{UnivariateFunctionData,Float64}","page":"Reference","title":"PolyhedralRelaxations._validate_point","text":"_validate_point(univariate_function_data, x)\n\nInput data point validator\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.construct_univariate_relaxation!-Tuple{JuMP.Model,Function,JuMP.VariableRef,JuMP.VariableRef,Array{var\"#s19\",1} where var\"#s19\"<:Real,Bool}","page":"Reference","title":"PolyhedralRelaxations.construct_univariate_relaxation!","text":"construct_univariate_relaxation!(m,x,y,f,x_partition;f_dash=x->ForwardDiff.derivative(f,x),error_tolerance=NaN64,length_tolerance=ϵ,derivative_tolerance=ϵ,num_additional_partitions=0)\n\nAdd MILP relaxation of y=f(x) to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\nf::Function: function or oracle for which a polyhedral relaxation is   required, usually non-linear.\nx::Jump.VariableRef: JuMP variable for domain of f.\ny::JuMP.VariableRef: JuMP variable for evaluation of f.\nx_partition::Vector{<:Real}: partition of the domain of f.\nmilp::Bool: build MILP relaxation if true, LP relaxation otherwise. Note   that the MILP relaxation uses the incremental formulation presented in the   paper, but the LP relaxation uses a lambda form that builds a formulation   as the convex combination of triangle vertices that are at the intersection   of tangents to the curve.\n\nOptional Arguments\n\nf_dash::Function: function or oracle for derivative of f, defaults to    the derivative function from the ForwardDiff package.\nerror_tolerance::Float64: Maximum allowed vertical distance between over   and under estimators of f, defaults to NaN64.\nlength_tolerance::Float64: maximum length of a sub-interval in a partition,   defaults to 0.001.\nderivative_tolerance::Float64: minimum absolute difference between   derivaties at successive elements of a partition for them to be considered   different, defaults to 0.001. If the difference of a partition sub-interval   is smaller than this value, that sub-interval will be refined.\nnum_additional_partitions::Int64: budget on number of sub-intervals in   partition, defaults to 0. Note that if the number of partitions is n and   the number of additional partitions is m, then the function will return a   relaxation with at most n+m partitions.\n\nAssume that:\n\nf is a bounded function of 1 variable.\nx_partition is a partition of the domain of f such that f is either   convex or concave each sub-interval of the partition.\nf_dash is not equal at two consecutive elements of x_partition.\n\nThis function builds an incremental formulation, which is the formulation presented in the paper.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.logger_config!-Tuple{Any}","page":"Reference","title":"PolyhedralRelaxations.logger_config!","text":"Allows users to set the logging level without adding Memento.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.silence-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.silence","text":"Suppresses information and warning messages output by PolyhedralRelaxations. For fine grained control use the Memento package.\n\n\n\n\n\n","category":"method"},{"location":"#PolyhedralRelaxations.jl-Documentation","page":"Introduction","title":"PolyhedralRelaxations.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = PolyhedralRelaxations","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PolyhedralRelaxations.jl is a Julia/JuMP package for constructing Polyhedral Relaxations for graphs of bounded, differentiable, univariate functions. In particular, it can be used to construct a sequence of both MILP and LP relaxation that converge to the graph of the univariate function and its convex hull, respectively. It takes in the function with its domain and the JuMP variables and the JuMP model and populates the model with the relaxation. It returns variable and constraint references for the formulated relaxation. ","category":"page"},{"location":"#Installation-Guide","page":"Introduction","title":"Installation Guide","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use PolyhedralRelaxations, first download and install Julia or open up a remote notebook at JuliaBox or similar services.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This version of PolyhedralRelaxations is compatible with Julia 1.0 and later.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From Julia REPL, PolyhedralRelaxations is installed by using the built-in package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"PolyhedralRelaxations\")","category":"page"},{"location":"#Unit-Tests","page":"Introduction","title":"Unit Tests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To run the tests in the package, run the following command within the Julia REPL after installing the package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.test(\"PolyhedralRelaxations\")","category":"page"},{"location":"#Quick-Introduction-to-the-Theory","page":"Introduction","title":"Quick Introduction to the Theory","text":"","category":"section"},{"location":"#Geometry-of-relaxations","page":"Introduction","title":"Geometry of relaxations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This quick start guide will introduce the main concepts of PolyhedralRelaxations. The package constructs MILP and LP relaxations for y = f(x), given the function and discretization points on the domain of f(x). For instance, given y=x^3 and a partition of the domain -15 0 2, it constructs an MILP relaxation of y = x^3 as the disjunction of the triangles shown in the figure below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: example)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice from the above example that, for the above disjunction of triangles to be a valid relaxation for y = f(x), the partition points must necessarily include the inflection points of the univariate function. Also, in the above example, the domain of the function y = x^3 is given by -15 2. The following table provides a list of inflection points for various well-used univariate functions. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Function Inflection points\nx^n (n is odd) 0\nx^n (n is even) phi\nsin x npi (n in mathbb Z)\ncos x nfracpi2 (n is odd )\nxx 0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the domain of the provided function contains an inflection point, then the requirement is that the inflection points should be provided as a discretization point; failing which the MILP relaxation need not be valid for the given function. ","category":"page"},{"location":"#Type-of-formulation-used","page":"Introduction","title":"Type of formulation used","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The MILP formulation, obtained as the disjunction of the triangles, is formulated using the incremental method (using the so-called delta variables) and the convex hull of the triangles (the LP) is formulated using the standard lambda-method (V-representation). For details on the formulation and theoretical properties, interested readers are referred to the following paper:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"K. Sundar, S. Sanjeevi, and H, Nagarajan (2020). Sequence of Polyhedral Relaxations for Nonlinear Univariate Functions. (arxiv link)","category":"page"}]
}
